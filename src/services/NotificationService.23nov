// Real-Time Notification Service for Visitor QR Scans
// Author: MiniMax Agent

export interface VisitorScanAlert {
  id: string;
  campaignId: string;
  campaignName: string;
  visitorType: 'checkin' | 'claim';
  location: string;
  mallName: string;
  shopName: string;
  timestamp: Date;
  scanId: string;
}

export interface NotificationSettings {
  soundEnabled: boolean;
  pushEnabled: boolean;
  visualEnabled: boolean;
  pollingInterval: number; // seconds
}

class NotificationService {
  private subscribers: Array<(alerts: VisitorScanAlert[]) => void> = [];
  private currentAlerts: VisitorScanAlert[] = [];
  private pollingIntervalId: number | null = null;
  private settings: NotificationSettings = {
    soundEnabled: true,
    pushEnabled: false, // Will be enabled after user permission
    visualEnabled: true,
    pollingInterval: 30 // Poll every 30 seconds
  };
  private lastPollTime: Date = new Date(0); // Never polled
  private audio: HTMLAudioElement | null = null;

  constructor() {
    this.initializeAudio();
    this.loadSettings();
    this.loadStoredAlerts();
  }

  private initializeAudio() {
    try {
      // Create a simple beep sound for notifications
      this.audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBjuA2O/BeyoGN4PL8t2QQAkPZrTp5qZOEA');
    } catch (error) {
      console.warn('Audio notification not available:', error);
    }
  }

  private loadSettings() {
    const stored = localStorage.getItem('notification_settings');
    if (stored) {
      this.settings = { ...this.settings, ...JSON.parse(stored) };
    }
  }

  private saveSettings() {
    localStorage.setItem('notification_settings', JSON.stringify(this.settings));
  }

  private loadStoredAlerts() {
    const stored = localStorage.getItem('visitor_alerts');
    if (stored) {
      try {
        const alerts = JSON.parse(stored);
        this.currentAlerts = alerts.map((alert: any) => ({
          ...alert,
          timestamp: new Date(alert.timestamp)
        }));
      } catch (error) {
        console.warn('Failed to load stored alerts:', error);
      }
    }
  }

  private saveAlerts() {
    localStorage.setItem('visitor_alerts', JSON.stringify(this.currentAlerts));
  }

  // Request permission for push notifications
  async requestPushPermission(): Promise<boolean> {
    if (!('Notification' in window)) {
      console.warn('This browser does not support notifications');
      return false;
    }

    if (Notification.permission === 'granted') {
      this.settings.pushEnabled = true;
      this.saveSettings();
      return true;
    }

    if (Notification.permission !== 'denied') {
      const permission = await Notification.requestPermission();
      const granted = permission === 'granted';
      this.settings.pushEnabled = granted;
      this.saveSettings();
      return granted;
    }

    return false;
  }

  // Start polling for new visitor scans
  startPolling(userMallId: number, userShopId: number) {
    if (this.pollingIntervalId) {
      clearInterval(this.pollingIntervalId);
    }

    this.pollingIntervalId = window.setInterval(() => {
      this.checkForNewScans(userMallId, userShopId);
    }, this.settings.pollingInterval * 1000);

    // Initial poll
    this.checkForNewScans(userMallId, userShopId);
  }

  // Stop polling
  stopPolling() {
    if (this.pollingIntervalId) {
      clearInterval(this.pollingIntervalId);
      this.pollingIntervalId = null;
    }
  }

  // Check for new visitor scans via N8N webhooks
  private async checkForNewScans(mallId: number, shopId: number) {
    try {
      console.log('ðŸ” Checking for new visitor scans...');
      
      // Query the visitor check-ins webhook for new activity
      // We'll use the existing webhook but with a different approach
      const response = await fetch('https://n8n.tenear.com/webhook/visitor-checkins', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          action: 'check_new_scans',
          mall_id: mallId,
          shop_id: shopId,
          last_check: this.lastPollTime.toISOString(),
          timestamp: new Date().toISOString()
        })
      });

      if (response.ok) {
        const data = await response.json();
        
        if (data.new_scans && Array.isArray(data.new_scans)) {
          const newAlerts: VisitorScanAlert[] = data.new_scans.map((scan: any) => ({
            id: `${scan.id}_${Date.now()}`,
            campaignId: scan.campaign_id,
            campaignName: scan.campaign_name || 'Unknown Campaign',
            visitorType: scan.type || 'checkin',
            location: scan.location_name || scan.location || 'Unknown Location',
            mallName: scan.mall_name || 'Unknown Mall',
            shopName: scan.shop_name || 'Unknown Shop',
            timestamp: new Date(scan.timestamp),
            scanId: scan.id
          }));

          // Add new alerts
          this.addNewAlerts(newAlerts);
        }
      }

      this.lastPollTime = new Date();
      
    } catch (error) {
      console.warn('Failed to check for new scans:', error);
    }
  }

  // Add new alerts and notify subscribers
  private addNewAlerts(alerts: VisitorScanAlert[]) {
    let hasNewAlerts = false;
    
    alerts.forEach(alert => {
      // Check if this alert is new (not already in current alerts)
      if (!this.currentAlerts.some(existing => existing.scanId === alert.scanId)) {
        this.currentAlerts.unshift(alert); // Add to beginning
        hasNewAlerts = true;

        // Play sound if enabled
        if (this.settings.soundEnabled && this.audio) {
          this.audio.play().catch(console.warn);
        }

        // Show push notification if enabled
        if (this.settings.pushEnabled && Notification.permission === 'granted') {
          this.showPushNotification(alert);
        }

        // Show visual notification
        if (this.settings.visualEnabled) {
          this.showVisualNotification(alert);
        }
      }
    });

    // Keep only the last 50 alerts
    if (this.currentAlerts.length > 50) {
      this.currentAlerts = this.currentAlerts.slice(0, 50);
    }

    // Save to localStorage
    this.saveAlerts();

    // Notify subscribers if there are new alerts
    if (hasNewAlerts) {
      this.notifySubscribers();
    }
  }

  // Show browser push notification
  private showPushNotification(alert: VisitorScanAlert) {
    const notification = new Notification('New Visitor Scan!', {
      body: `${alert.visitorType === 'checkin' ? 'Check-in' : 'Claim'} at ${alert.location}`,
      icon: '/favicon.ico',
      badge: '/favicon.ico',
      tag: `scan-${alert.scanId}`
    });

    notification.onclick = () => {
      window.focus();
      notification.close();
    };

    // Auto close after 5 seconds
    setTimeout(() => notification.close(), 5000);
  }

  // Show visual toast notification
  private showVisualNotification(alert: VisitorScanAlert) {
    const toast = document.createElement('div');
    toast.className = `
      fixed top-4 right-4 z-50 bg-white border border-gray-200 rounded-lg shadow-lg p-4 max-w-sm
      transform transition-all duration-500 ease-in-out translate-x-full
    `;
    
    toast.innerHTML = `
      <div class="flex items-start space-x-3">
        <div class="flex-shrink-0">
          <div class="w-3 h-3 rounded-full ${alert.visitorType === 'checkin' ? 'bg-green-400' : 'bg-blue-400'}"></div>
        </div>
        <div class="flex-1 min-w-0">
          <p class="text-sm font-medium text-gray-900">
            New ${alert.visitorType === 'checkin' ? 'Check-in' : 'Claim'}!
          </p>
          <p class="text-sm text-gray-500">
            ${alert.location} â€¢ ${alert.timestamp.toLocaleTimeString()}
          </p>
          <p class="text-xs text-gray-400 mt-1">
            ${alert.campaignName}
          </p>
        </div>
        <button onclick="this.parentElement.parentElement.remove()" class="flex-shrink-0 text-gray-400 hover:text-gray-600">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>
    `;

    document.body.appendChild(toast);

    // Animate in
    setTimeout(() => {
      toast.classList.remove('translate-x-full');
    }, 100);

    // Auto remove after 10 seconds
    setTimeout(() => {
      toast.classList.add('translate-x-full');
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 500);
    }, 10000);
  }

  // Subscribe to alerts (for React components)
  subscribe(callback: (alerts: VisitorScanAlert[]) => void) {
    this.subscribers.push(callback);
    
    // Immediately call with current alerts
    callback(this.currentAlerts);
    
    // Return unsubscribe function
    return () => {
      const index = this.subscribers.indexOf(callback);
      if (index > -1) {
        this.subscribers.splice(index, 1);
      }
    };
  }

  // Notify all subscribers
  private notifySubscribers() {
    this.subscribers.forEach(callback => {
      try {
        callback(this.currentAlerts);
      } catch (error) {
        console.error('Error in notification subscriber:', error);
      }
    });
  }

  // Get current alerts
  getAlerts(): VisitorScanAlert[] {
    return [...this.currentAlerts];
  }

  // Mark alerts as read
  markAsRead(alertIds: string[]) {
    this.currentAlerts = this.currentAlerts.filter(alert => !alertIds.includes(alert.id));
    this.saveAlerts();
    this.notifySubscribers();
  }

  // Clear all alerts
  clearAllAlerts() {
    this.currentAlerts = [];
    this.saveAlerts();
    this.notifySubscribers();
  }

  // Update notification settings
  updateSettings(newSettings: Partial<NotificationSettings>) {
    this.settings = { ...this.settings, ...newSettings };
    this.saveSettings();
    
    // If push is being enabled, request permission
    if (newSettings.pushEnabled === true && !this.settings.pushEnabled) {
      this.requestPushPermission();
    }
  }

  // Get current settings
  getSettings(): NotificationSettings {
    return { ...this.settings };
  }
}

// Create singleton instance
export const notificationService = new NotificationService();
